"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2952],{13002:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>y,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var a=t(85893),s=t(11151),i=t(74866),r=t(85162);const l={slug:"big-data-types-library",title:"Big Data Types Library",authors:"javier",tags:["Scala","Spark","Big-query","Cassandra","Circe","type-class","type-safe","type-derivation","type-level-programming"]},o="Scala Big Data Types Library",c={permalink:"/blog/big-data-types-library",editUrl:"https://github.com/JavierMonton/blog/edit/main/website/blog/2021-10-10-big-data-types/index.md",source:"@site/blog/2021-10-10-big-data-types/index.md",title:"Big Data Types Library",description:"Big Data Types is a library that can safely convert types between different Big Data systems.",date:"2021-10-10T00:00:00.000Z",formattedDate:"October 10, 2021",tags:[{label:"Scala",permalink:"/blog/tags/scala"},{label:"Spark",permalink:"/blog/tags/spark"},{label:"Big-query",permalink:"/blog/tags/big-query"},{label:"Cassandra",permalink:"/blog/tags/cassandra"},{label:"Circe",permalink:"/blog/tags/circe"},{label:"type-class",permalink:"/blog/tags/type-class"},{label:"type-safe",permalink:"/blog/tags/type-safe"},{label:"type-derivation",permalink:"/blog/tags/type-derivation"},{label:"type-level-programming",permalink:"/blog/tags/type-level-programming"}],readingTime:8.615,hasTruncateMarker:!1,authors:[{name:"Javier Mont\xf3n",title:"Software Engineer",url:"https://github.com/JavierMonton",imageURL:"https://github.com/JavierMonton.png",key:"javier"}],frontMatter:{slug:"big-data-types-library",title:"Big Data Types Library",authors:"javier",tags:["Scala","Spark","Big-query","Cassandra","Circe","type-class","type-safe","type-derivation","type-level-programming"]},unlisted:!1,prevItem:{title:"Kafka Connect - JDBC Sink",permalink:"/blog/kafka-connect-jdbc-sink-iam-auth"}},d={authorsImageUrls:[void 0]},h=[{value:"The power of the library",id:"the-power-of-the-library",level:2},{value:"How the library works",id:"how-the-library-works",level:2},{value:"Modules",id:"modules",level:3},{value:"Generic type",id:"generic-type",level:3},{value:"Repeated values",id:"repeated-values",level:4},{value:"Nested values",id:"nested-values",level:4},{value:"Type-class derivation",id:"type-class-derivation",level:2},{value:"Implementing a new type",id:"implementing-a-new-type",level:2},{value:"Using conversions",id:"using-conversions",level:2},{value:"Extension methods",id:"extension-methods",level:2},{value:"More types to come",id:"more-types-to-come",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Big Data Types is a library that can safely convert types between different Big Data systems."}),"\n",(0,a.jsx)(n.h2,{id:"the-power-of-the-library",children:"The power of the library"}),"\n",(0,a.jsx)(n.p,{children:"The library implements a few abstract types that can hold any kind of structure, and using type-class derivations,\nit can convert between multiple types without having any code relating them. In other words, there is no need to implement a transformation between type A to type B, the library will do it for you."}),"\n",(0,a.jsxs)(n.p,{children:["As an example, let's say we have a generic type called ",(0,a.jsx)(n.code,{children:"Generic"}),". Now we want to convert from type ",(0,a.jsx)(n.code,{children:"A"})," to type ",(0,a.jsx)(n.code,{children:"B"}),".\nIf we implement the conversion from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"Generic"})," and the conversion from ",(0,a.jsx)(n.code,{children:"Generic"})," to ",(0,a.jsx)(n.code,{children:"B"}),", automatically we can convert from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"B"})," although there is no single line of code mixing ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["We can also do the opposite, we can convert from ",(0,a.jsx)(n.code,{children:"B"})," to ",(0,a.jsx)(n.code,{children:"A"})," by implementing the conversion from ",(0,a.jsx)(n.code,{children:"B"})," to ",(0,a.jsx)(n.code,{children:"Generic"})," and the conversion from ",(0,a.jsx)(n.code,{children:"Generic"})," to ",(0,a.jsx)(n.code,{children:"A"}),". Now we can convert between ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"})," as we wish."]}),"\n",(0,a.jsxs)(n.p,{children:["Now comes the good part of this. If we introduce a new type ",(0,a.jsx)(n.code,{children:"C"})," and we want to have conversions, we would need to convert from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"C"}),", and from ",(0,a.jsx)(n.code,{children:"B"})," to ",(0,a.jsx)(n.code,{children:"C"})," and the opposite ",(0,a.jsx)(n.strong,{children:"(4 new implementations)"}),".\nIf now we introduce ",(0,a.jsx)(n.code,{children:"D"}),", we would need to implement the conversion from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"D"}),", from ",(0,a.jsx)(n.code,{children:"B"})," to ",(0,a.jsx)(n.code,{children:"D"})," and from ",(0,a.jsx)(n.code,{children:"C"})," to ",(0,a.jsx)(n.code,{children:"D"})," and the opposite ",(0,a.jsx)(n.strong,{children:"(6 new implementations)"}),". This is not scalable, and it is not maintainable."]}),"\n",(0,a.jsxs)(n.p,{children:["Having this ",(0,a.jsx)(n.code,{children:"Generic"})," type means that when we introduce ",(0,a.jsx)(n.code,{children:"C"}),", we only need to implement the conversion from ",(0,a.jsx)(n.code,{children:"C"})," to ",(0,a.jsx)(n.code,{children:"Generic"})," and from ",(0,a.jsx)(n.code,{children:"Generic"})," to ",(0,a.jsx)(n.code,{children:"C"}),", without worrying at all about other implementations or types.\nMoreover, is likely that the conversion will be very similar to others, so we can reuse some of the code."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["It is important to know that one of these types is the Scala types themselves. So if we want to convert from ",(0,a.jsx)(n.code,{children:"Scala types"})," (like ",(0,a.jsx)(n.code,{children:"case classes"}),") to another type, we only need to implement ",(0,a.jsx)(n.code,{children:"Generic -> newType"})]})}),"\n",(0,a.jsx)(n.h2,{id:"how-the-library-works",children:"How the library works"}),"\n",(0,a.jsx)(n.h3,{id:"modules",children:"Modules"}),"\n",(0,a.jsxs)(n.p,{children:["As mentioned, the library has multiple modules, each one of them representing a different system with its own types. Each module implements the conversion from and to ",(0,a.jsx)(n.code,{children:"Generic"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["For now, the modules are ",(0,a.jsx)(n.code,{children:"core"})," (for Scala types and common code), ",(0,a.jsx)(n.code,{children:"BigQuery"}),", ",(0,a.jsx)(n.code,{children:"Cassandra"}),", ",(0,a.jsx)(n.code,{children:"Circe"}),", and ",(0,a.jsx)(n.code,{children:"Spark"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To use the library, only the modules that are needed should be imported. For example, if we want to convert from ",(0,a.jsx)(n.code,{children:"Scala types"})," to ",(0,a.jsx)(n.code,{children:"BigQuery"})," types, we only need to ",(0,a.jsx)(n.code,{children:"BigQuery"})," module. (",(0,a.jsx)(n.code,{children:"Core"})," module is always included as a dependency)\nIf we want to convert from ",(0,a.jsx)(n.code,{children:"Spark"})," to ",(0,a.jsx)(n.code,{children:"BigQuery"})," we need to import both ",(0,a.jsx)(n.code,{children:"Spark"})," and ",(0,a.jsx)(n.code,{children:"BigQuery"})," modules."]}),"\n",(0,a.jsx)(n.h3,{id:"generic-type",children:"Generic type"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Generic"})," type is called ",(0,a.jsx)(n.code,{children:"SqlType"})," and it's implemented as ",(0,a.jsx)(n.a,{href:"https://github.com/data-tools/big-data-types/blob/main/core/src/main/scala_2/org/datatools/bigdatatypes/basictypes/SqlType.scala",children:"sealed trait"})," that can hold any kind of structure.\nIn Scala 3, this type is implemented as an ",(0,a.jsx)(n.a,{href:"https://github.com/data-tools/big-data-types/blob/main/core/src/main/scala_3/org/datatools/bigdatatypes/basictypes/SqlType.scala",children:"enum"})," but both represents the same."]}),"\n",(0,a.jsx)(n.h4,{id:"repeated-values",children:"Repeated values"}),"\n",(0,a.jsxs)(n.p,{children:["Usually, there are two ways of implementing a repeated value like an Array. Some systems use a type like ",(0,a.jsx)(n.code,{children:"Array"})," or ",(0,a.jsx)(n.code,{children:"List"}),"\nand others flag a basic type with ",(0,a.jsx)(n.code,{children:"repeated"}),". The implementation of this ",(0,a.jsx)(n.code,{children:"SqlType"})," uses the latter,\nso any basic type can have a ",(0,a.jsx)(n.code,{children:"mode"})," that can be ",(0,a.jsx)(n.code,{children:"Required"}),", ",(0,a.jsx)(n.code,{children:"Nullable"}),", or ",(0,a.jsx)(n.code,{children:"Repeated"}),". This is closer to the ",(0,a.jsx)(n.code,{children:"BigQuery"})," implementation."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This implementation does not allow for ",(0,a.jsx)(n.code,{children:"Nullable"})," and ",(0,a.jsx)(n.code,{children:"Repeated"})," at the same time, but a ",(0,a.jsx)(n.code,{children:"Repeated"})," type can have 0 elements."]})}),"\n",(0,a.jsx)(n.h4,{id:"nested-values",children:"Nested values"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SqlStruct"})," can hold a list of records, including other ",(0,a.jsx)(n.code,{children:"SqlStruct"}),", meaning that we can have nested structures."]}),"\n",(0,a.jsx)(n.h2,{id:"type-class-derivation",children:"Type-class derivation"}),"\n",(0,a.jsx)(n.p,{children:'Type-classes are a way of implementing "ad-hoc polymorphism". This means that we can implement behaviour for a type without having to modify the type itself.\nIn Scala, we achieve this through implicits.'}),"\n",(0,a.jsx)(n.p,{children:"The interesting part of type-classes for this library is that we can derive a type-class for a type without having to implement it."}),"\n",(0,a.jsx)(n.p,{children:"For example, we can create a simple type-class:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait MyTypeClass[A] {\n  def doSomething(a: A): String\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["A type-class is always a ",(0,a.jsx)(n.code,{children:"trait"})," with a generic type."]})}),"\n",(0,a.jsxs)(n.p,{children:["Then, we can implement our type-class for an ",(0,a.jsx)(n.code,{children:"Int"})," type:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'implicit val myTypeClassForInt: MyTypeClass[Int] = new MyTypeClass[Int] {\n  override def doSomething(a: Int): String = "This is my int" + a.toString\n}\n'})}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsx)(n.p,{children:"Scala 2.13 has a simplified syntax for this when there is only one method in the trait:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'implicit val myTypeClassForInt: MyTypeClass[Int] = (a: Int) => "This is my int" + a.toString\n'})})]}),"\n",(0,a.jsx)(n.p,{children:"We can do similar for other types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'implicit val myTypeClassForString: MyTypeClass[String] = new MyTypeClass[String] {\n  override def doSomething(a: String): String = "This is my String" + a\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now, if we want to have a ",(0,a.jsx)(n.code,{children:"List[Int]"})," or a ",(0,a.jsx)(n.code,{children:"List[String]"}),", and use our type-class, we need to implement both ",(0,a.jsx)(n.code,{children:"List[Int]"})," and ",(0,a.jsx)(n.code,{children:"List[String]"}),".\n",(0,a.jsx)(n.strong,{children:"But"}),", if we implement the type-class for ",(0,a.jsx)(n.code,{children:"List[A]"})," where ",(0,a.jsx)(n.code,{children:"A"})," is any type, the compiler can derive the implementation for ",(0,a.jsx)(n.code,{children:"List[Int]"})," and ",(0,a.jsx)(n.code,{children:"List[String]"})," automatically, and for any other type already implemented."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'implicit def myTypeClassForList[A](implicit myTypeClassForA: MyTypeClass[A]): MyTypeClass[List[A]] = new MyTypeClass[List[A]] {\n  override def doSomething(a: List[A]): String = a.map(myTypeClassForA.doSomething).mkString(",")\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, if we want to have a ",(0,a.jsx)(n.code,{children:"case class"})," like:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"case class MyClass(a: Int, b: String)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We would need to implement the type-class for ",(0,a.jsx)(n.code,{children:"MyClass"}),". But, if we implement the type-class for a generic ",(0,a.jsx)(n.code,{children:"Product"})," type, the compiler can derive the implementation for ",(0,a.jsx)(n.code,{children:"MyClass"})," automatically, and for any other ",(0,a.jsx)(n.code,{children:"case class"})," that has types already implemented."]}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["Implementing the conversion for a ",(0,a.jsx)(n.code,{children:"Product"})," type is more complex than implementing it for a ",(0,a.jsx)(n.code,{children:"List"})," type, and usually ",(0,a.jsx)(n.a,{href:"https://github.com/milessabin/shapeless",children:"Shapeless"})," is the library we use to do this in Scala 2."]}),(0,a.jsxs)(n.p,{children:["In Scala 3, the language already allows us to derive the type-class for a ",(0,a.jsx)(n.code,{children:"Product"})," type, so we don't need to use Shapeless."]}),(0,a.jsxs)(n.p,{children:["In ",(0,a.jsx)(n.a,{href:"https://github.com/data-tools/big-data-types",children:"big-data-types"})," we have the implementation for all basic types, including iterables and ",(0,a.jsx)(n.code,{children:"Product"})," types ",(0,a.jsx)(n.a,{href:"https://github.com/data-tools/big-data-types/blob/main/core/src/main/scala_2/org/datatools/bigdatatypes/conversions/SqlTypeConversion.scala",children:"here for Scala 2"}),"\nand ",(0,a.jsx)(n.a,{href:"https://github.com/data-tools/big-data-types/blob/main/core/src/main/scala_3/org/datatools/bigdatatypes/conversions/SqlTypeConversion.scala",children:"here for Scala 3"}),"."]})]}),"\n",(0,a.jsx)(n.h2,{id:"implementing-a-new-type",children:"Implementing a new type"}),"\n",(0,a.jsxs)(n.p,{children:["To implement a new type, we need to implement the conversion from and to ",(0,a.jsx)(n.code,{children:"Generic"})," type. There is a complete guide, step by step, with examples, in the ",(0,a.jsx)(n.a,{href:"https://data-tools.github.io/big-data-types/docs/Contributing/CreateNewType",children:"official documentation"})]}),"\n",(0,a.jsxs)(n.p,{children:["A quick example, let's say we want to implement a new type called ",(0,a.jsx)(n.code,{children:"MyType"}),". We need to implement the conversion ",(0,a.jsx)(n.code,{children:"MyType -> Generic"})," and ",(0,a.jsx)(n.code,{children:"Generic -> MyType"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Both conversions are not strictly needed, if we only need to use ",(0,a.jsx)(n.code,{children:"Scala -> MyType"})," we only need to implement ",(0,a.jsx)(n.code,{children:"Generic -> MyType"}),"\nbecause the library already has the conversion ",(0,a.jsx)(n.code,{children:"Scala -> Generic"}),". The same happens with other types, like ",(0,a.jsx)(n.code,{children:"BigQuery -> MyType"})," will also be ready automatically."]})}),"\n",(0,a.jsx)(n.p,{children:"To do that, we need a type-class that works with our type. This will be different depending on the type we want to implement.\nFor example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait GenericToMyType[A] {\n  def getType: MyTypeObject\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Maybe our type works with a List at the top level, as Spark does, so instead, we will do:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait GenericToMyType[A] {\n  def getType: List[MyTypeObject]\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"getType"})," can be renamed to anything meaningful, like ",(0,a.jsx)(n.code,{children:"toMyType"})," or ",(0,a.jsx)(n.code,{children:"myTypeSchema"})]})}),"\n",(0,a.jsxs)(n.p,{children:["And we need to implement this type-class for all the (Generic) ",(0,a.jsx)(n.code,{children:"SqlType"})," types:"]}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsx)(r.Z,{value:"Scala2",label:"Scala 2",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"implicit val genericToMyTypeForInt: GenericToMyType[SqlInt] = new GenericToMyType[SqlInt] {\n  override def getType: MyTypeObject = MyIntType\n}\n"})})}),(0,a.jsx)(r.Z,{value:"Scala3",label:"Scala 3",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"given GenericToMyType[SqlInt] = new GenericToMyType[SqlInt] {\n    override def getType: MyTypeObject = MyIntType\n}\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"using-conversions",children:"Using conversions"}),"\n",(0,a.jsxs)(n.p,{children:["The defined type-classes allow you to convert ",(0,a.jsx)(n.code,{children:"MyType -> Generic"})," by doing this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val int: SqlInt = SqlTypeConversion[MyIntType].getType\n"})}),"\n",(0,a.jsxs)(n.p,{children:["And ",(0,a.jsx)(n.code,{children:"Generic -> MyType"})," by doing this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val int: MyIntType = SqlTypeToBigQuery[SqlInt].getType\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This can work well when we work these ",(0,a.jsx)(n.code,{children:"case classes"})," and we don't have an instance of them. For example, a ",(0,a.jsx)(n.code,{children:"case class"})," definition can be converted into a ",(0,a.jsx)(n.code,{children:"BigQuery"})," Schema, ready to be used for table creation."]}),"\n",(0,a.jsx)(n.p,{children:"But, sometimes, our types work with instances rather than definitions, and we need to use them to convert to other types."}),"\n",(0,a.jsx)(n.p,{children:"There is another type-class on all implemented types that allows to work with instances. In general, this type-class can be implemented using code from the other, but this one expects an argument of the type we want to convert to."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait SqlInstanceToMyType[A] {\n  def myTypeSchema(value: A): MyTypeObject\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Implementing this type-class allows to use the conversion like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val mySchema: MyTypeObject = SqlInstanceToMyType.myTypeSchema(theOtherType)\n"})}),"\n",(0,a.jsx)(n.p,{children:"But these syntaxis are not very friendly, and we can use extension methods to make it more readable."}),"\n",(0,a.jsx)(n.h2,{id:"extension-methods",children:"Extension methods"}),"\n",(0,a.jsx)(n.p,{children:"Extension methods in Scala 2 are done through implicit classes and allow us to create new methods for existing types."}),"\n",(0,a.jsxs)(n.p,{children:["In the library, we implement extension methods for ",(0,a.jsx)(n.code,{children:"Generic -> SpecificType"}),", and the interesting part, again, is that we don't need to implement ",(0,a.jsx)(n.code,{children:"A -> B"})," directly, the compiler can derive it for us."]}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsx)(r.Z,{value:"Scala2",label:"Scala 2",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"  implicit class InstanceSyntax[A: SqlInstanceToMyType](value: A) {\n    def asMyType: MyTypeObject = SqlInstanceToMyType[A].myTypeSchema(value)\n  }\n"})})}),(0,a.jsx)(r.Z,{value:"Scala3",label:"Scala 3",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"  extension[A: SqlInstanceToMyType](value: A) {\n    def asMyType: MyTypeObject = SqlInstanceToMyType[A].myTypeSchema(value)\n  }\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"and suddenly, we can use the conversion like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val mySchema: MyTypeObject = theOtherType.asMyType\n"})}),"\n",(0,a.jsx)(n.p,{children:"And this is a syntax that can be easier to use. For example, if we work with Spark and BigQuery, we can do the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val sparkDf: DataFrame = ???\nval bigQuerySchema = sparkDf.schema.asBigQuery\n"})}),"\n",(0,a.jsx)(n.h2,{id:"more-types-to-come",children:"More types to come"}),"\n",(0,a.jsx)(n.p,{children:"The library has only a few types implemented (BigQuery, Spark, Cassandra, and Circe) but implementing a new type is fairly easy and it gets automatically methods that can be used to convert it into any other type already implemented.\nAs this grows, the number of conversions grows exponentially, and the library becomes more powerful."}),"\n",(0,a.jsx)(n.p,{children:"Some types that could be potentially implemented:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Avro"}),"\n",(0,a.jsx)(n.li,{children:"Parquet"}),"\n",(0,a.jsx)(n.li,{children:"Athena (AWS)"}),"\n",(0,a.jsx)(n.li,{children:"Redshift (AWS)"}),"\n",(0,a.jsx)(n.li,{children:"Snowflake"}),"\n",(0,a.jsx)(n.li,{children:"RDS (relational databases)"}),"\n",(0,a.jsx)(n.li,{children:"Protobuf"}),"\n",(0,a.jsx)(n.li,{children:"ElasticSearch templates"}),"\n",(0,a.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Some types could have some restrictions, but they could be implemented differently, for example,\na type conversion could be implemented as a ",(0,a.jsx)(n.code,{children:"String"}),' conversion, being the string a "Create table" statement for a specific database\nand automatically any other type could be printed as a "Create table" statement.']})]})}function y(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},85162:(e,n,t)=>{t.d(n,{Z:()=>r});t(67294);var a=t(90512);const s={tabItem:"tabItem_Ymn6"};var i=t(85893);function r(e){let{children:n,hidden:t,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.Z)(s.tabItem,r),hidden:t,children:n})}},74866:(e,n,t)=>{t.d(n,{Z:()=>w});var a=t(67294),s=t(90512),i=t(12466),r=t(16550),l=t(20469),o=t(91980),c=t(67392),d=t(50012);function h(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:s}}=e;return{value:n,label:t,attributes:a,default:s}}))}(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function y(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const s=(0,r.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o._X)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(s.location.search);n.set(i,e),s.replace({...s.location,search:n.toString()})}),[i,s])]}function u(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,i=p(e),[r,o]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!y({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[c,h]=m({queryString:t,groupId:s}),[u,x]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,i]=(0,d.Nk)(t);return[s,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:s}),j=(()=>{const e=c??u;return y({value:e,tabValues:i})?e:null})();(0,l.Z)((()=>{j&&o(j)}),[j]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!y({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),h(e),x(e)}),[h,x,i]),tabValues:i}}var x=t(72389);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=t(85893);function b(e){let{className:n,block:t,selectedValue:a,selectValue:r,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.o5)(),d=e=>{const n=e.currentTarget,t=o.indexOf(n),s=l[t].value;s!==a&&(c(n),r(s))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>o.push(e),onKeyDown:h,onClick:d,...i,className:(0,s.Z)("tabs__item",j.tabItem,i?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function f(e){let{lazy:n,children:t,selectedValue:s}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===s));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function v(e){const n=u(e);return(0,g.jsxs)("div",{className:(0,s.Z)("tabs-container",j.tabList),children:[(0,g.jsx)(b,{...e,...n}),(0,g.jsx)(f,{...e,...n})]})}function w(e){const n=(0,x.Z)();return(0,g.jsx)(v,{...e,children:h(e.children)},String(n))}},11151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>r});var a=t(67294);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);