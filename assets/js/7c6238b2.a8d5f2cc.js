"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1392],{44290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=n(85893),a=n(11151);n(74866),n(85162);const o={slug:"kafka-connect-mm2-offset-management",title:"Kafka Connect, MM2, and Offset Management",authors:"javier",tags:["Scala","Java","Kafka","Kafka-Connect","MM2","offsets","MSK","Mirror-Maker2"]},r="Kafka Connect, MM2, and Offset Management",i={permalink:"/blog/kafka-connect-mm2-offset-management",editUrl:"https://github.com/JavierMonton/blog/edit/main/website/blog/2024-04-13-kafka-connect-mm2-offset-management/index.md",source:"@site/blog/2024-04-13-kafka-connect-mm2-offset-management/index.md",title:"Kafka Connect, MM2, and Offset Management",description:"This post is about Kafka Connect, Mirror Maker 2, how they manage offsets, and how to deal with them.",date:"2024-04-13T00:00:00.000Z",formattedDate:"April 13, 2024",tags:[{label:"Scala",permalink:"/blog/tags/scala"},{label:"Java",permalink:"/blog/tags/java"},{label:"Kafka",permalink:"/blog/tags/kafka"},{label:"Kafka-Connect",permalink:"/blog/tags/kafka-connect"},{label:"MM2",permalink:"/blog/tags/mm-2"},{label:"offsets",permalink:"/blog/tags/offsets"},{label:"MSK",permalink:"/blog/tags/msk"},{label:"Mirror-Maker2",permalink:"/blog/tags/mirror-maker-2"}],readingTime:6.35,hasTruncateMarker:!1,authors:[{name:"Javier Mont\xf3n",title:"Software Engineer",url:"https://github.com/JavierMonton",imageURL:"https://github.com/JavierMonton.png",key:"javier"}],frontMatter:{slug:"kafka-connect-mm2-offset-management",title:"Kafka Connect, MM2, and Offset Management",authors:"javier",tags:["Scala","Java","Kafka","Kafka-Connect","MM2","offsets","MSK","Mirror-Maker2"]},unlisted:!1,prevItem:{title:"Kafka - Reassign Partitions",permalink:"/blog/kafka-reassign-partitions"},nextItem:{title:"Kafka Connect - JDBC Sink",permalink:"/blog/kafka-connect-jdbc-sink-iam-auth"}},c={authorsImageUrls:[void 0]},l=[{value:"Kafka Offsets",id:"kafka-offsets",level:2},{value:"Monitoring offset lag",id:"monitoring-offset-lag",level:3},{value:"Kafka Connect Offsets",id:"kafka-connect-offsets",level:2},{value:"Mirror Maker 2 (MM2) Offsets",id:"mirror-maker-2-mm2-offsets",level:2},{value:"Mixing Kafka Connect and MM2",id:"mixing-kafka-connect-and-mm2",level:2},{value:"Kafka Connect topic",id:"kafka-connect-topic",level:3},{value:"MM2 topic",id:"mm2-topic",level:3},{value:"Hot to reset offsets in Mirror Maker 2",id:"hot-to-reset-offsets-in-mirror-maker-2",level:2},{value:"Manual edit of offsets",id:"manual-edit-of-offsets",level:3},{value:"REST API to reset offsets",id:"rest-api-to-reset-offsets",level:3},{value:"TL;DR",id:"tldr",level:2}];function f(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"This post is about Kafka Connect, Mirror Maker 2, how they manage offsets, and how to deal with them."}),"\n",(0,s.jsx)(t.h2,{id:"kafka-offsets",children:"Kafka Offsets"}),"\n",(0,s.jsxs)(t.p,{children:["When a consumer starts consuming messages from Kafka, it will probably use a ",(0,s.jsx)(t.code,{children:"consumer-group"})," and Kafka will store the\noffset of the last message consumed by that consumer-group. This offset is stored in a Kafka topic called ",(0,s.jsx)(t.code,{children:"__consumer_offsets"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"By doing this, when the consumer restarts, it can start consuming messages from the last offset it consumed."}),"\n",(0,s.jsx)(t.p,{children:"There are tools that allow us to manage these offsets, like the binary files provided by Kafka, and in any case,\nthe consumer can always decide which offsets to consume from. This means that the consumer can set the offset to the beginning,\nthe end, or any other offset. A lot of tools allow even to search offsets based on timestamps."}),"\n",(0,s.jsx)(t.h3,{id:"monitoring-offset-lag",children:"Monitoring offset lag"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"consumer-offset-lag"})," is a metric provided by Kafka, based on the difference between the last offset consumed by the consumer\nand the last offset produced by the producer. Most of the monitoring tools will have this value, like DataDog,\nand it is very useful to know if the consumer is lagging, meaning that it is not consuming messages as fast as they are produced, or it is down."]}),"\n",(0,s.jsxs)(t.p,{children:["But ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.strong,{children:"Mirror Maker 2 (MM2) can not be monitored through this metric"})}),", see below."]}),"\n",(0,s.jsx)(t.h2,{id:"kafka-connect-offsets",children:"Kafka Connect Offsets"}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"When we talk about Kafka Connect, we are talking about the distributed version of Kafka Connect, not the standalone version."})}),"\n",(0,s.jsxs)(t.p,{children:["Kafka Connect manage offsets in their own way. When a consumer is started by Kafka Connect, it will store the offsets in a Kafka topic\ncalled ",(0,s.jsx)(t.code,{children:"connect-offsets"})," by default, although it can be configured through the ",(0,s.jsx)(t.code,{children:"offset.storage.topic"})," property."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:['When a connector is created in Kafka Connect, it will track the offsets in its own topic, but it also will use a regular "consumer-group" so the offsets will be also tracked in ',(0,s.jsx)(t.code,{children:"__consumer_offsets"}),".\nThis also means that we can monitor Kafka Connect sinks through the ",(0,s.jsx)(t.code,{children:"consumer-offset-lag"})," metric."]})}),"\n",(0,s.jsx)(t.h2,{id:"mirror-maker-2-mm2-offsets",children:"Mirror Maker 2 (MM2) Offsets"}),"\n",(0,s.jsx)(t.p,{children:"Mirror Maker 2 is a tool provided by Kafka to replicate messages from one Kafka cluster to another, it is meant to be used for a complete replication between clusters,\nbut it can be used to copy only some topics."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["MM2 can be run in different ways, but here we are talking about the ",(0,s.jsx)(t.code,{children:"Kafka Connect"})," way, where MM2 is run as a Kafka Connect connector."]})}),"\n",(0,s.jsx)(t.p,{children:"If we think about MM2 and the data it needs to consume and produce, we can have doubts about how offsets can be managed.\nTo start with, it needs to read in one cluster and write on another, so, how does it manage the offsets?"}),"\n",(0,s.jsxs)(t.p,{children:["By default, MM2 will create a topic called ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})," and as far asI know, it can not be renamed."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:'While working with MM2, it is recommended to install the connectors in the "target" cluster, so the "source" cluster will be the external one.'})}),"\n",(0,s.jsx)(t.p,{children:'By default, MM2 will create the aforementioned topic in the "source" cluster, and it will store the offsets of the last message consumed and produced.\nBut as we can see, the "source" cluster is "external" to where the Kafka Connect is installed, and that might cause some issues\nin cases where the "source" cluster is not managed by us. For example, we might not have write or create access, and we can not create the topic.'}),"\n",(0,s.jsxs)(t.p,{children:["The destination of ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})," can be defined by the ",(0,s.jsxs)(t.a,{href:"https://kafka.apache.org/documentation/#mirror_source_offset-syncs.topic.location",children:[(0,s.jsx)(t.code,{children:"offset-syncs.topic.location"})," property"]})," which accepts ",(0,s.jsx)(t.code,{children:"source"})," (default) and ",(0,s.jsx)(t.code,{children:"target"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["When a Consumer is created by MM2, which is a Kafka Connect connector, it will store the offsets both in ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})," and in ",(0,s.jsx)(t.code,{children:"connect-offsets"}),".\nThis is very important if we want to manipulate offsets"]})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["MM2 consumers do not use a ",(0,s.jsx)(t.code,{children:"group.id"}),", they do not use any Kafka consumer group and their consumed offset won't be stored in ",(0,s.jsx)(t.code,{children:"__consumer_offsets"}),".\nThis also means that we can not monitor MM2 through the ",(0,s.jsx)(t.code,{children:"consumer-offset-lag"})," metric."]})}),"\n",(0,s.jsx)(t.h2,{id:"mixing-kafka-connect-and-mm2",children:"Mixing Kafka Connect and MM2"}),"\n",(0,s.jsx)(t.p,{children:"If we look at the offsets stored both by Kafka Connect and MM2 in their topics, we can see the following:"}),"\n",(0,s.jsx)(t.h3,{id:"kafka-connect-topic",children:"Kafka Connect topic"}),"\n",(0,s.jsxs)(t.p,{children:["If we look at the ",(0,s.jsx)(t.code,{children:"connect-offsets"})," topic, we can see that the offsets are stored in JSON format, with the following structure:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"key"})," is a structure that contains the connector name, the partition, the topic, and the cluster."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'[\n\t"my-connector-name",\n\t{\n\t\t"cluster": "my-source-cluster-alias",\n\t\t"partition": 3,\n\t\t"topic": "my-example-topic"\n\t}\n]\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["And the ",(0,s.jsx)(t.code,{children:"value"})," is a JSON with the offset:"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n    "offset": 1234\n}\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:'No matter where we store the offsets (source or target), Kafka Connect will show the "source cluster alias" as this is where the Kafka consumer is created.'})}),"\n",(0,s.jsx)(t.h3,{id:"mm2-topic",children:"MM2 topic"}),"\n",(0,s.jsxs)(t.p,{children:["If we look at the ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})," topic, we can see KC uses its own format to store the offsets:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"key"})," is the connector name, but it has a few extra bytes, which represents some structure defined inside the code"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"value"})," is just an Int64, which represents the offset"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Managing offsets is not really recommended as we could mess up the connectors, but it is possible to do it."}),"\n",(0,s.jsx)(t.h2,{id:"hot-to-reset-offsets-in-mirror-maker-2",children:"Hot to reset offsets in Mirror Maker 2"}),"\n",(0,s.jsxs)(t.p,{children:["If we need to reset the offsets in MM2, we might think that deleting the topic ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})," will do the trick,\nbut it won't, as offsets are also stored in Kafka Connect's topic. So, we need to reset the offsets in both topics."]}),"\n",(0,s.jsx)(t.p,{children:"There is a lot of misinformation about how to reset the offsets in Kafka Connect, their docs are not very clear about it, and Kafka Connect has been lacking tools to work with it.\nTypically, removing the connector and creating it with a different name will do the trick, but we might want to keep the same name."}),"\n",(0,s.jsx)(t.h3,{id:"manual-edit-of-offsets",children:"Manual edit of offsets"}),"\n",(0,s.jsxs)(t.p,{children:["We can manually produce a message in the ",(0,s.jsx)(t.code,{children:"connect-offsets"})," topic to reset offsets, and the right way of doing it is to send a ",(0,s.jsx)(t.code,{children:"tombstone"}),".\nWe can check the messages we have right now, identify the connector we want and send the same Key with ",(0,s.jsx)(t.code,{children:"null"})," value."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["To reset offsets completely we do not specify ",(0,s.jsx)(t.code,{children:"offset: 0"}),", we send a null value"]})}),"\n",(0,s.jsx)(t.h3,{id:"rest-api-to-reset-offsets",children:"REST API to reset offsets"}),"\n",(0,s.jsxs)(t.p,{children:["Starting from ",(0,s.jsx)(t.a,{href:"https://archive.apache.org/dist/kafka/3.6.0/RELEASE_NOTES.html",children:"Kafka 3.6.0"}),", Kafka Connect has a REST API to manage connectors, and it is possible to reset offsets through it.\nThe docs about it are defined in the ",(0,s.jsx)(t.a,{href:"https://cwiki.apache.org/confluence/display/KAFKA/KIP-875%3A+First-class+offsets+support+in+Kafka+Connect#KIP875:FirstclassoffsetssupportinKafkaConnect-PublicInterfaces",children:"KPI-875"}),", but they are still not present in the official docs.\nIf you are using Confluent, starting from ",(0,s.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/release-notes/index.html",children:"Confluent's 7.6.0 version"})," Kafka 3.6.0 is included."]}),"\n",(0,s.jsx)(t.p,{children:"If we use this version, we can simply do a few curls to reset offsets. First we need to stop the connector and then reset the offsets."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"curl -X PUT http://localhost:8083/connectors/my-connector-name/offsets/stop\ncurl -X DELETE http://localhost:8083/connectors/my-connector-name/offsets\n"})}),"\n",(0,s.jsx)(t.p,{children:"We can also know the status of the offsets:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"curl -X GET http://localhost:8083/connectors/my-connector-name/offsets | jq\n"})}),"\n",(0,s.jsx)(t.h2,{id:"tldr",children:"TL;DR"}),"\n",(0,s.jsx)(t.p,{children:"To reset offsets in MM2, you need to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Stop, pause or remove the connectors"}),"\n",(0,s.jsxs)(t.li,{children:["Delete or truncate the topic ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})]}),"\n",(0,s.jsxs)(t.li,{children:["Reset the offsets in the ",(0,s.jsx)(t.code,{children:"connect-offsets"})," topic, either manually or through the REST API for the desired connector"]}),"\n",(0,s.jsx)(t.li,{children:"Start the connectors again"}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["Deleting the topic ",(0,s.jsx)(t.code,{children:"mm2-offset-syncs.<cluster-alias>.internal"})," will not reset the offsets for other connectors you have configured in MM2\nas they fall back to the ",(0,s.jsx)(t.code,{children:"connect-offsets"})," topic, but be careful and do this at your own risk, things might change in the future and this could become false."]})})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}},85162:(e,t,n)=>{n.d(t,{Z:()=>r});n(67294);var s=n(90512);const a={tabItem:"tabItem_Ymn6"};var o=n(85893);function r(e){let{children:t,hidden:n,className:r}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,s.Z)(a.tabItem,r),hidden:n,children:t})}},74866:(e,t,n)=>{n.d(t,{Z:()=>y});var s=n(67294),a=n(90512),o=n(12466),r=n(16550),i=n(20469),c=n(91980),l=n(67392),f=n(50012);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function d(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:a}}=e;return{value:t,label:n,attributes:s,default:a}}))}(n);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function u(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,r.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,c._X)(o),(0,s.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function p(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=d(e),[r,c]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!u({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:o}))),[l,h]=m({queryString:n,groupId:a}),[p,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,f.Nk)(n);return[a,(0,s.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),k=(()=>{const e=l??p;return u({value:e,tabValues:o})?e:null})();(0,i.Z)((()=>{k&&c(k)}),[k]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!u({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),g(e)}),[h,g,o]),tabValues:o}}var g=n(72389);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(85893);function x(e){let{className:t,block:n,selectedValue:s,selectValue:r,tabValues:i}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.o5)(),f=e=>{const t=e.currentTarget,n=c.indexOf(t),a=i[n].value;a!==s&&(l(t),r(a))},h=e=>{let t=null;switch(e.key){case"Enter":f(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},t),children:i.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>c.push(e),onKeyDown:h,onClick:f,...o,className:(0,a.Z)("tabs__item",k.tabItem,o?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function w(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function j(e){const t=p(e);return(0,b.jsxs)("div",{className:(0,a.Z)("tabs-container",k.tabList),children:[(0,b.jsx)(x,{...e,...t}),(0,b.jsx)(w,{...e,...t})]})}function y(e){const t=(0,g.Z)();return(0,b.jsx)(j,{...e,children:h(e.children)},String(t))}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>r});var s=n(67294);const a={},o=s.createContext(a);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);