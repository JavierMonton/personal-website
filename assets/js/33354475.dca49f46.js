"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6053],{91168:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(74848),r=n(28453);const s={slug:"kafka-connect-protobuf",title:"Kafka Connect - Protobuf Converters",authors:"javier",tags:["kafka-connect","protobuf","source","sink","schema-registry"]},a="Kafka Connect & Protobuf",i={permalink:"/blog/kafka-connect-protobuf",editUrl:"https://github.com/JavierMonton/blog/edit/main/website/blog/2025-02-22-kafka-connect-probotuf/index.md",source:"@site/blog/2025-02-22-kafka-connect-probotuf/index.md",title:"Kafka Connect - Protobuf Converters",description:"Kafka Connect is a tool that allows you to stream data between Apache Kafka and other systems,",date:"2025-02-22T00:00:00.000Z",formattedDate:"February 22, 2025",tags:[{label:"kafka-connect",permalink:"/blog/tags/kafka-connect"},{label:"protobuf",permalink:"/blog/tags/protobuf"},{label:"source",permalink:"/blog/tags/source"},{label:"sink",permalink:"/blog/tags/sink"},{label:"schema-registry",permalink:"/blog/tags/schema-registry"}],readingTime:6.3,hasTruncateMarker:!1,authors:[{name:"Javier Mont\xf3n",title:"Software Engineer",url:"https://github.com/JavierMonton",imageURL:"https://github.com/JavierMonton.png",key:"javier"}],frontMatter:{slug:"kafka-connect-protobuf",title:"Kafka Connect - Protobuf Converters",authors:"javier",tags:["kafka-connect","protobuf","source","sink","schema-registry"]},unlisted:!1,nextItem:{title:"Kafka - Reassign Partitions",permalink:"/blog/kafka-reassign-partitions"}},c={authorsImageUrls:[void 0]},l=[{value:"Protobuf Converters",id:"protobuf-converters",level:2},{value:"How Converters work",id:"how-converters-work",level:2},{value:"Sink &amp; Protobuf Converter",id:"sink--protobuf-converter",level:2},{value:"Source &amp; Protobuf Converter",id:"source--protobuf-converter",level:2},{value:"Schema Registry &amp; Protobuf Converter",id:"schema-registry--protobuf-converter",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Kafka Connect is a tool that allows you to stream data between Apache Kafka and other systems,\nsometimes the data might be converted from Protobuf to something different, other times, it might be converted to Protobuf."}),"\n",(0,o.jsx)(t.h2,{id:"protobuf-converters",children:"Protobuf Converters"}),"\n",(0,o.jsxs)(t.p,{children:["Confluent has a ",(0,o.jsx)(t.a,{href:"https://docs.confluent.io/platform/current/schema-registry/connect.html#protobuf",children:"Protobuf Converter"}),"\nthat can be used with any Kafka Connect Source or Sink, but it isn't as simple as it seems."]}),"\n",(0,o.jsx)(t.p,{children:"If you enable:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-properties",children:"key.converter=io.confluent.connect.protobuf.ProtobufConverter\nvalue.converter.schema.registry.url=http://localhost:8081\n"})}),"\n",(0,o.jsx)(t.p,{children:"If you use this in a Sink connector, Kafka Connect will understand how to deserialize the Protobuf message in Kafka, but how will it write it to the sink?"}),"\n",(0,o.jsx)(t.p,{children:"If you enable this in a Source connector, Kafka Connect will be able to serialize the message to Protobuf, but what was it expecting from the Source?"}),"\n",(0,o.jsx)(t.p,{children:"In some connectors, like a JDBC, it might be obvious that the database has a proper schema defined, but in others, like S3 or SQS, there is no schema defined, so, how will Kafka Connect know how to read/write the data?"}),"\n",(0,o.jsx)(t.h2,{id:"how-converters-work",children:"How Converters work"}),"\n",(0,o.jsxs)(t.p,{children:["Inside Kafka Connect, the data is represented using the classes in ",(0,o.jsx)(t.code,{children:"org.apache.kafka.connect.data"}),", which can be ",(0,o.jsx)(t.code,{children:"Struct"}),","]}),"\n",(0,o.jsx)(t.h2,{id:"sink--protobuf-converter",children:"Sink & Protobuf Converter"}),"\n",(0,o.jsxs)(t.p,{children:["In a Sink, the ProtobufConverter (the same as the Avro converter or any other) transforms the data read from Kafka into this ",(0,o.jsx)(t.a,{href:"https://github.com/a0x8o/kafka/blob/master/connect/api/src/main/java/org/apache/kafka/connect/data/Struct.java",children:"Struct"})," class, with its fields and schema.\nFrom there, the Sink connector decides how to write these objects in the destination. If we use a destination that requires a schema, like an RDS, the connector will likely know (and probably need) how to write these ",(0,o.jsx)(t.code,{children:"structs"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["If we use a plugin that writes into a schemaless system, like S3 or SQS, nothing prevents the connector from writing data other than JSON or similar.\n",(0,o.jsxs)(t.em,{children:["The connector needs to transform the ",(0,o.jsx)(t.code,{children:"struct"})," into JSON if that's what we want"]}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"source--protobuf-converter",children:"Source & Protobuf Converter"}),"\n",(0,o.jsxs)(t.p,{children:["Here is where it gets tricky. If we use a Protobuf converter in a Source connector, we are telling the converter to transform the ",(0,o.jsx)(t.code,{children:"Struct"})," into Protobuf, but the connector needs to produce this ",(0,o.jsx)(t.code,{children:"Struct"}),".\nIn a structured source, like an RDS, it is easy to know how to produce the ",(0,o.jsx)(t.code,{children:"Struct"}),", but in a schemaless source, like S3 or SQS, it is not that easy, the Source connector should be expecting something like a JSON, and it will need to parse it properly, generating a ",(0,o.jsx)(t.code,{children:"schema"})," and a ",(0,o.jsx)(t.code,{children:"struct"}),", otherwise, the Protobuf converter won't know what to do."]}),"\n",(0,o.jsxs)(t.p,{children:["At EF, we have ",(0,o.jsx)(t.a,{href:"https://github.com/efcloud/kafka-connect-sqs",children:"modified an SQS Source connector"})," to allow automatic conversions from JSON to ",(0,o.jsx)(t.code,{children:"Struct"}),", so the Protobuf or any other converter can work properly."]}),"\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsxs)(t.p,{children:["Note that parsing automatically JSONs to be converted into ",(0,o.jsx)(t.code,{children:"Struct"})," or ",(0,o.jsx)(t.code,{children:"Protobuf"})," is not trivial due to the light types of JSON. For example, a numeric Timestamp in JSON is no different from a numeric value, so you cannot know if it's a Timestamp or an Integer, or Long. JSON doesn't have enums, so a String cannot be converted into an ",(0,o.jsx)(t.code,{children:"Enumeration"})," automatically, etc."]})}),"\n",(0,o.jsxs)(t.p,{children:["But that's not all, ",(0,o.jsx)(t.em,{children:"how will this Protobuf Converter interact with Schema Registry?"})," There are several issues depending on the configuration."]}),"\n",(0,o.jsx)(t.h2,{id:"schema-registry--protobuf-converter",children:"Schema Registry & Protobuf Converter"}),"\n",(0,o.jsx)(t.p,{children:"The Confluent's ProtobufConverter is designed to use the following configuration, which is the default one:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-properties",children:"value.converter.auto.register.schemas=true\nvalue.converter.use.latest.version=false\nvalue.converter.latest.compatibility.strict=true\n"})}),"\n",(0,o.jsx)(t.p,{children:"In this way, a Source Connector in Kafka Connect will produce a new Protobuf Schema, and it will register the Schema in Schema Registry.\nBut the schema registered will be something similar to this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-protobuf",children:'syntax = "proto3";\nmessage ConnectDefault1 {\n  string id = 1;\n  int32 value = 2;\n  repeated string tags = 3;\n  google.protobuf.Timestamp updatedAt = 4;\n  ConnectDefault2 sub = 5;\n\n  message ConnectDefault2 {\n    string name = 1;\n    string description = 2;\n    int32 value = 3;\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["As we can see, it decides to create messages named ",(0,o.jsx)(t.code,{children:"ConnectDefault1"})," and ",(0,o.jsx)(t.code,{children:"ConnectDefault2"}),", which are fine if we don't care much about controlling our own schemas."]}),"\n",(0,o.jsx)(t.p,{children:"If a new message has a different schema than the first registered, and it's not compatible (following our compatibility configurations), it will fail."}),"\n",(0,o.jsx)(t.p,{children:"But, what happens if we don't want Kafka Connect to write the schema in Schema Registry? We could disable the option, so this will be our config:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-properties",children:"value.converter.auto.register.schemas=false\nvalue.converter.use.latest.version=true\nvalue.converter.latest.compatibility.strict=true\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In this situation, we are registering the schema on our side, maybe we are calling our main object ",(0,o.jsx)(t.code,{children:"MainObject"})," rather than ",(0,o.jsx)(t.code,{children:"ConnectDefault1"}),". But here is where the issues start to appear, the ProtobufConverter will try to validate the schema in Schema Registry, and it will fail, because it is expecting a ",(0,o.jsx)(t.code,{children:"ConnectDefault1"})," and we are sending a ",(0,o.jsx)(t.code,{children:"MainObject"}),".\nWe could solve this by using the ",(0,o.jsx)(t.a,{href:"https://docs.confluent.io/kafka-connectors/transforms/current/setschemametadata.html#set-a-namespace-and-schema-name",children:"SetSchemaMetadata SMT"})," to set the schema name and namespace. But we still have issues with the order of the fields, more details later."]}),"\n",(0,o.jsxs)(t.p,{children:["So, maybe we can disable the ",(0,o.jsx)(t.code,{children:"value.converter.latest.compatibility.strict=false"})," if we know the schemas are the same?"]}),"\n",(0,o.jsx)(t.p,{children:"We could do it, yes, then, the ProtobufConverter won't compare the schemas, it will serialize the message and send it to Kafka.\nIf the message has exactly the same schema, it will work, if not, it will still send the message to Kafka."}),"\n",(0,o.jsxs)(t.p,{children:["And probably ",(0,o.jsx)(t.strong,{children:"the worst scenario"}),", lets imagine that a new event comes with fields in different order. We know that the ",(0,o.jsx)(t.code,{children:"Struct"})," holds information about the field names and types, so it shouldn't cause any issue. We also know that an input message in a format like JSON also specifies the field names, so far so good.\nBut, Protobuf cares about the order of the fields, not just about their names, and the ",(0,o.jsx)(t.code,{children:"ProtobufConverter"})," doesn't know which the expected order.\nLook at the previous Protobuf definition, a new message might come with ",(0,o.jsx)(t.code,{children:"id"})," and ",(0,o.jsx)(t.code,{children:"value"})," in different order, the ",(0,o.jsx)(t.code,{children:"ProtobufConverter"})," will produce a schema like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-protobuf",children:'syntax = "proto3";\nmessage ConnectDefault1 {\n  int32 value = 1;\n  string id = 2;\n  repeated string tags = 3;\n  google.protobuf.Timestamp updatedAt = 4;\n  ConnectDefault2 sub = 5;\n\n  message ConnectDefault2 {\n    string name = 1;\n    string description = 2;\n    int32 value = 3;\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"id"})," and ",(0,o.jsx)(t.code,{children:"value"})," are in different order. If we have the ",(0,o.jsx)(t.code,{children:"value.converter.latest.compatibility.strict"})," set to ",(0,o.jsx)(t.code,{children:"true"}),", this will cause an error, if we have it as ",(0,o.jsx)(t.code,{children:"false"}),", the event will be produced to Kafka, but our consumers will read it wrong."]}),"\n",(0,o.jsxs)(t.admonition,{type:"warning",children:[(0,o.jsxs)(t.p,{children:["Even if we use ",(0,o.jsx)(t.code,{children:"value.converter.latest.compatibility.strict=true"}),", if we send a message that matches the schema in the order of the fields and their types, but not on the field names, it will still produce the message. For example, if our message looks like this:"]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'{\n  "anotherfield": "12345",\n  "value": 10,\n  "tags": ["exampleTag1", "exampleTag2"],\n  "updatedAt": "2023-10-01T12:34:56Z"\n}\n'})}),(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"ProtobufConverter"})," will serialize this message and produce it in Kafka. When a consumer reads this, it will use the Schema in Schema Registry,\nwhich has ",(0,o.jsx)(t.code,{children:"id"})," rather than ",(0,o.jsx)(t.code,{children:"anotherfield"}),", it will show the data on it.\nThis come become a big issue if our schema has a lot of fields with the same type, like ",(0,o.jsx)(t.code,{children:"string"}),",\nif a message has unordered fields, they will end up mixed."]})]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"If we are using a Source Connector with ProtobufConverter, we should use the default configuration"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-properties",children:"value.converter.auto.register.schemas=false\nvalue.converter.use.latest.version=true\nvalue.converter.latest.compatibility.strict=true\n"})}),"\n",(0,o.jsxs)(t.p,{children:["and ensure that the source messages have always the same schema, ",(0,o.jsx)(t.strong,{children:"including the order of the fields"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Otherwise, the system becomes too fragile, we could get a lot of failures, or we could produce messages we won't be able to read.\nEven with the default configuration, we should ensure that messages in the source don't change the order of the fields, as this will cause issues with Protobuf."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(96540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);